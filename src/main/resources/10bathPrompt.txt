## Complete Summary: Current Code + Refactor Plan

---

### PART 1: YOUR CURRENT CODE (What You Have)

**Package Structure:**
```
application/
‚îú‚îÄ‚îÄ Main.java
‚îú‚îÄ‚îÄ GameManager.java
logic/
‚îú‚îÄ‚îÄ Card.java
‚îú‚îÄ‚îÄ AttackCard.java
‚îú‚îÄ‚îÄ SkillCard.java
‚îú‚îÄ‚îÄ PowerCard.java (empty)
‚îú‚îÄ‚îÄ Player.java
‚îú‚îÄ‚îÄ Enemy.java
‚îú‚îÄ‚îÄ EnemyIntent.java
‚îú‚îÄ‚îÄ CardType.java (enum)
‚îú‚îÄ‚îÄ Rarity.java (enum)
‚îú‚îÄ‚îÄ EnemyIntentType.java (enum)
```

**Current GameManager:**
- Singleton ‚úÖ
- Holds `Player player` and `ArrayList<Enemy> enemies` separately

**Current Card System:**
- `execute()` takes no parameters
- `SkillCard.execute()` reaches into `GameManager` to get player
- `AttackCard` has no `execute()` override yet

---

### PART 2: REFACTOR PLAN (What To Change)

#### Step 1: Create `BaseUnit` (New File)

```java
package logic;

import java.util.ArrayList;

public abstract class BaseUnit {
    protected String name;
    protected int hp;
    protected int maxHp;
    protected int block;
    protected ArrayList<Buff> buffs;  // for later

    public BaseUnit(String name, int hp, int maxHp) {
        this.name = name;
        this.hp = hp;
        this.maxHp = maxHp;
        this.block = 0;
        this.buffs = new ArrayList<>();
    }

    public void takeDamage(int damage) {
        // Later: calculate through buffs/debuffs
        int actualDamage = damage - this.block;
        if (actualDamage < 0) actualDamage = 0;
        this.block -= damage;
        if (this.block < 0) this.block = 0;
        this.hp -= actualDamage;
    }

    // Getters/Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getHp() { return hp; }
    public void setHp(int hp) { this.hp = hp; }
    public int getMaxHp() { return maxHp; }
    public void setMaxHp(int maxHp) { this.maxHp = maxHp; }
    public int getBlock() { return block; }
    public void setBlock(int block) { this.block = block; }
}
```

---

#### Step 2: Refactor `Player` (extends BaseUnit)

```java
package logic;

import java.util.ArrayList;
import java.util.Collections;

public class Player extends BaseUnit {
    private int currentEnergy;
    private int maxEnergy;
    private int gold;
    private ArrayList<Card> deck = new ArrayList<>();

    public Player(String name, int hp, int maxHp, int maxEnergy, int block, int gold) {
        super(name, hp, maxHp);  // calls BaseUnit constructor
        this.currentEnergy = maxEnergy;
        this.maxEnergy = maxEnergy;
        this.block = block;
        this.gold = gold;
        setBeginCard();
    }

    void setBeginCard() {
        for (int i = 0; i < 20; i++) {
            SkillCard defend = new SkillCard(
                i, "Defend", "Gain " + (4 * i + 2) + " Block",
                Rarity.COMMON, CardType.SKILL, 4 * i + 2
            );
            deck.add(defend);
        }
        Collections.shuffle(deck);
    }

    // Player-specific getters/setters
    public int getCurrentEnergy() { return currentEnergy; }
    public void setCurrentEnergy(int e) { this.currentEnergy = e; }
    public int getMaxEnergy() { return maxEnergy; }
    public void setMaxEnergy(int e) { this.maxEnergy = e; }
    public int getGold() { return gold; }
    public void setGold(int g) { this.gold = g; }
    public ArrayList<Card> getDeck() { return deck; }
    public void setDeck(ArrayList<Card> d) { this.deck = d; }

    @Override
    public String toString() {
        return "Player{name='" + name + "', hp=" + hp + "/" + maxHp +
               ", energy=" + currentEnergy + "/" + maxEnergy +
               ", block=" + block + ", gold=" + gold + "}";
    }
}
```

---

#### Step 3: Refactor `Enemy` (extends BaseUnit)

```java
package logic;

import java.util.ArrayList;

public class Enemy extends BaseUnit {
    private ArrayList<EnemyIntent> enemyIntentPattern = new ArrayList<>();

    public Enemy(int hp, int maxHp, String name) {
        super(name, hp, maxHp);  // calls BaseUnit constructor
        setBeginPattern();
    }

    public void setBeginPattern() {
        enemyIntentPattern.add(new EnemyIntent(EnemyIntentType.ATTACK, 11));
        enemyIntentPattern.add(new EnemyIntent(EnemyIntentType.BLOCK, 7));
    }

    public ArrayList<EnemyIntent> getEnemyIntentPattern() {
        return enemyIntentPattern;
    }

    @Override
    public String toString() {
        return "Enemy{name='" + name + "', hp=" + hp + "/" + maxHp +
               ", intents=" + enemyIntentPattern + "}";
    }
}
```

---

#### Step 4: Refactor `GameManager` (ArrayList\<BaseUnit\>)

```java
package application;

import logic.BaseUnit;
import Unit.Enemy;
import Unit.Player;

import java.util.ArrayList;

public class GameManager {
    private static GameManager gameManager;
    private ArrayList<BaseUnit> units;

    private GameManager() {
        units = new ArrayList<>();
    }

    public static synchronized GameManager getInstance() {
        if (gameManager == null) {
            gameManager = new GameManager();
        }
        return gameManager;
    }

    // Player is always index 0
    public void setPlayer(Player player) {
        if (units.isEmpty()) {
            units.add(player);
        } else {
            units.set(0, player);
        }
    }

    public Player getPlayer() {
        return (Player) units.get(0);
    }

    public void addEnemy(Enemy enemy) {
        units.add(enemy);
    }

    public ArrayList<BaseUnit> getAllUnits() {
        return units;
    }

    // Get enemies only (index 1+)
    public ArrayList<Enemy> getEnemies() {
        ArrayList<Enemy> enemies = new ArrayList<>();
        for (int i = 1; i < units.size(); i++) {
            enemies.add((Enemy) units.get(i));
        }
        return enemies;
    }

    // Reset for new battle
    public void clearEnemies() {
        while (units.size() > 1) {
            units.remove(units.size() - 1);
        }
    }
}
```

---

#### Step 5: Refactor `Card` (execute takes BaseUnit)

```java
package logic;

public abstract class Card {
    protected int cost;
    protected String name;
    protected String description;
    protected Rarity rarity;
    protected CardType cardType;

    public Card(int cost, String name, String description, Rarity rarity, CardType cardType) {
        this.cost = cost;
        this.name = name;
        this.description = description;
        this.rarity = rarity;
        this.cardType = cardType;
    }

    // Now takes target as parameter
    public abstract void execute(BaseUnit target);

    @Override
    public String toString() {
        return "Card{cost=" + cost + ", name='" + name + "', " +
               "description='" + description + "', rarity=" + rarity + "}";
    }
}
```

---

#### Step 6: Refactor `SkillCard`

```java
package logic;

public class SkillCard extends Card {
    protected int block;

    public SkillCard(int cost, String name, String description,
                     Rarity rarity, CardType cardType, int block) {
        super(cost, name, description, rarity, cardType);
        this.block = block;
    }

    @Override
    public void execute(BaseUnit target) {
        // Target should be the player
        target.setBlock(target.getBlock() + this.block);
        System.out.println("Playing " + name + ": " + description);
        System.out.println(target.getName() + " now has " + target.getBlock() + " block");
    }
}
```

---

#### Step 7: Refactor `AttackCard`

```java
package logic;

public class AttackCard extends Card {
    private int damage;

    public AttackCard(int cost, String name, String description,
                      Rarity rarity, CardType cardType, int damage) {
        super(cost, name, description, rarity, cardType);
        this.damage = damage;
    }

    @Override
    public void execute(BaseUnit target) {
        // Target should be an enemy
        target.takeDamage(this.damage);
        System.out.println("Playing " + name + ": Dealt " + damage + " damage to " + target.getName());
        System.out.println(target.getName() + " now has " + target.getHp() + " hp");
    }
}
```

---

#### Step 8: Refactor `Main` (Prototype)

```java
package application;

import logic.*;

public class Main {
    public static void main(String[] args) {
        // Setup
        Player pp = new Player("PP", 80, 100, 3, 0, 99);
        Enemy battery = new Enemy(23, 23, "FD Battery");

        GameManager.getInstance().setPlayer(pp);
        GameManager.getInstance().addEnemy(battery);

        // Get references
        BaseUnit player = GameManager.getInstance().getPlayer();
        BaseUnit enemy = GameManager.getInstance().getEnemies().get(0);

        System.out.println("=== BATTLE START ===");
        System.out.println(player);
        System.out.println(enemy);

        // Play a skill card (target = player)
        SkillCard defend = new SkillCard(1, "Defend", "Gain 5 Block",
                                          Rarity.COMMON, CardType.SKILL, 5);
        defend.execute(player);

        // Play an attack card (target = enemy)
        AttackCard strike = new AttackCard(1, "Strike", "Deal 6 Damage",
                                            Rarity.COMMON, CardType.ATTACK, 6);
        strike.execute(enemy);

        System.out.println("=== AFTER CARDS ===");
        System.out.println(player);
        System.out.println(enemy);
    }
}
```

---

### PART 3: KEY DECISIONS SUMMARY

| Decision | Choice | Reason |
|----------|--------|--------|
| Entity storage | `ArrayList<BaseUnit>` | Unified list, no index bugs |
| Card execution | `execute(BaseUnit target)` | Caller decides target, not card |
| Player position | Always index 0 | Simple, predictable |
| Who passes target | `Main` (later GUI) | Battle system controls targeting |
| Buffs/debuffs | In `BaseUnit` | Both player and enemy can have them |
| Block | In `BaseUnit` | Enemy can block too |
| Prevent self-attack | GUI responsibility | Card doesn't need to know |

---

### PART 4: FUTURE TODO (Not Now)

- [ ] `Buff` class
- [ ] `PowerCard` implementation
- [ ] Damage calculation pipeline (Strength, Vulnerable, etc.)
- [ ] `DrawPile`, `Hand`, `DiscardPile` instead of just `deck`
- [ ] Energy consumption check before playing
- [ ] Turn system (player turn ‚Üí enemy turn)
- [ ] Enemy AI (cycle through intents)

---

Sleep well. Tomorrow: **Start with `BaseUnit`**, then refactor `Player` and `Enemy` to extend it. Everything else follows from there. üëç